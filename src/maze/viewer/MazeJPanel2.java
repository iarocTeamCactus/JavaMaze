/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package maze.viewer;

import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.util.HashSet;
import java.util.Set;

import sun.java2d.loops.DrawRect;

import maze.Direction;
import maze.MazeConstants;
import maze.builder.RandomMazeBuilder;
import maze.pieces.EmptySpace;
import maze.pieces.MazePiece;
import maze.pieces.UndefinedMazePiece;
import maze.pieces.Wall;
import maze.solver.MazeSolver;

/**
 * 
 * @author Rob.Erwin@gmail.com
 */
public class MazeJPanel2 extends javax.swing.JPanel {

	private Set<MazePiece> drawnPieces = new HashSet<>();
	private MazePiece mMiddlePiece;
	private int mTranslateY;
	private int mTranslateX;
	private double mScale;
	private int mEastWestSize;
	private int mNorthSouthSize;
	private int mNorthMostLoc, mSouthMostLoc, mEastMostLoc, mWestMostLoc;

	/**
	 * Creates new form MazeJPanel2
	 */
	public MazeJPanel2() {
		initComponents();

	}

	public void setMiddlePiece(MazePiece middlePiece) {
		mMiddlePiece = middlePiece;
		System.out
				.println("setting Middle Piece in MazeJpenl2 " + mMiddlePiece);
	}

	private void drawMaze(MazePiece currentPiece, double x, double y,
			Graphics2D g2) {
		// System.out.println("JPanel.drawMaze " + currentPiece);
		if (currentPiece != null) {
			// draw the current piece
			drawMazePiece(currentPiece, x, y, g2);

			// draw all empty spaces first
			MazePiece adjacentPiece;
			for (Direction direction : MazeConstants.DIRECTIONS) {
				adjacentPiece = currentPiece.getDirection(direction);
				if (adjacentPiece instanceof EmptySpace
						&& !drawnPieces.contains(adjacentPiece)) {
					// works here because all pieces are same size
					drawMaze(adjacentPiece,
							x + direction.getXdiff() * currentPiece.getWidth()
									/ 2.0 + direction.getXdiff()
									* adjacentPiece.getWidth() / 2.0,
							y + direction.getYdiff() * currentPiece.getHeight()
									/ 2.0 + direction.getYdiff()
									* adjacentPiece.getHeight() / 2.0, g2);
				}
			}
			// then draw all walls
			for (Direction direction : MazeConstants.DIRECTIONS) {
				adjacentPiece = currentPiece.getDirection(direction);
				if (adjacentPiece instanceof Wall
						&& !drawnPieces.contains(adjacentPiece)) {
					// THIS CODE WAS FROM BEFORE USING CenteredRectangle
					// if (direction == MazeConstants.NORTH) {
					// drawMaze(adjacentPiece, x + direction.getXdiff() *
					// currentPiece.getWidth(), y + direction.getYdiff() *
					// currentPiece.getHeight() * .5, g2);
					// } else if (direction == MazeConstants.EAST) {
					// drawMaze(adjacentPiece, x + direction.getXdiff() *
					// currentPiece.getWidth() - .5 * adjacentPiece.getWidth(),
					// y +
					// direction.getYdiff() * currentPiece.getHeight(), g2);
					// } else if (direction == MazeConstants.WEST) {
					// drawMaze(adjacentPiece, x + direction.getXdiff() *
					// adjacentPiece.getWidth() * .5, y + direction.getYdiff() *
					// adjacentPiece.getHeight(), g2);
					// } else {
					// drawMaze(adjacentPiece, x + direction.getXdiff() *
					// adjacentPiece.getWidth(), y + direction.getYdiff() *
					// adjacentPiece.getHeight() * .5, g2);
					// }
					drawMaze(adjacentPiece, x + direction.getXdiff()
							* currentPiece.getWidth() / 2.0,
							y + direction.getYdiff() * currentPiece.getHeight()
									/ 2.0, g2);

				}
			}
		}
	}

	private void drawMazePiece(MazePiece currentPiece, double x, double y,
			Graphics2D g2) {
		if (currentPiece != null) {
			if (!(currentPiece instanceof UndefinedMazePiece)) {
				Rectangle r = new CenteredRectangle((int) x, (int) y,
						(int) currentPiece.getWidth(),
						(int) currentPiece.getHeight());
				g2.setPaint(currentPiece.getColor());
				// Random rand = new Random();
				// g2.setPaint(new Color(rand.nextFloat(), rand.nextFloat(),
				// rand.nextFloat()));
				g2.fill(r);
				drawnPieces.add(currentPiece);
			}
		}
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
	// <editor-fold defaultstate="collapsed"
	// desc="Generated Code">//GEN-BEGIN:initComponents
	private void initComponents() {

		setBackground(new java.awt.Color(204, 255, 204));
		addMouseListener(new java.awt.event.MouseAdapter() {
			public void mouseClicked(java.awt.event.MouseEvent evt) {
				formMouseClicked(evt);
			}
		});
		addComponentListener(new java.awt.event.ComponentAdapter() {
			public void componentResized(java.awt.event.ComponentEvent evt) {
				formComponentResized(evt);
			}

			public void componentShown(java.awt.event.ComponentEvent evt) {
				formComponentShown(evt);
			}
		});

		javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
		this.setLayout(layout);
		layout.setHorizontalGroup(layout.createParallelGroup(
				javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 372,
				Short.MAX_VALUE));
		layout.setVerticalGroup(layout.createParallelGroup(
				javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 269,
				Short.MAX_VALUE));
	}// </editor-fold>//GEN-END:initComponents

	@Override
	public void paint(Graphics g) {
		Graphics2D g2 = (Graphics2D) g;
		super.paint(g2);
//		g2.drawRect(0,0,(int)mMiddlePiece.getWidth(),(int)mMiddlePiece.getHeight());
//		g2.drawRect(getWidth()-(int)mMiddlePiece.getWidth(), getHeight()- (int)mMiddlePiece.getHeight(), (int)mMiddlePiece.getWidth(), (int)mMiddlePiece.getHeight());
		g2.drawRect(getWidth()/2-(int)mMiddlePiece.getWidth()/2, getHeight()/2-(int)mMiddlePiece.getHeight()/2, (int)mMiddlePiece.getWidth(), (int)mMiddlePiece.getHeight());
		calculateScale();
		calculateTranslate();
		g2.translate(getWidth() * .5, getHeight() * .5);
		g2.scale(mScale, mScale);
		if ( mMiddlePiece != null ) {
//			System.out.println(mEastMostLoc + " " + mWestMostLoc + " " + mSouthMostLoc + " " + mNorthMostLoc);
			double transX, transY;
			transX = ( -1.0 * ( ( mEastMostLoc  - mWestMostLoc  + 1.0) / 2.0 + mWestMostLoc  ) + .5 ) * mMiddlePiece.getWidth();
			transY = ( -1.0 * ( ( mSouthMostLoc - mNorthMostLoc + 1.0) / 2.0 + mNorthMostLoc ) + .5 ) * mMiddlePiece.getHeight();
//			System.out.println(transX + " " + transY);
			g2.translate(transX, transY);
		}
		drawnPieces.clear();
//		g2.drawRect(0,0,(int)mMiddlePiece.getWidth(),(int)mMiddlePiece.getHeight());
//		g2.drawRect(getWidth()-(int)mMiddlePiece.getWidth(), getHeight()- (int)mMiddlePiece.getHeight(), (int)mMiddlePiece.getWidth(), (int)mMiddlePiece.getHeight());
		g2.drawRect(getWidth()/2-(int)mMiddlePiece.getWidth()/2, getHeight()/2-(int)mMiddlePiece.getHeight()/2, (int)mMiddlePiece.getWidth(), (int)mMiddlePiece.getHeight());

		drawMaze(mMiddlePiece, 0, 0,
				g2/* JFrame graphics */);
	}

	private void calculateTranslate() {
		// TODO Auto-generated method stub
		if (mMiddlePiece != null) {
			
		}

	}

	private void calculateScale() {
		if (mMiddlePiece != null) {
			mScale = (double)this.getHeight() / ( (double)mNorthSouthSize * (double)mMiddlePiece.getHeight() * 1.0 )
					* .90;
			mScale = Math.min(mScale, (double)this.getWidth() / ((double)mEastWestSize * (double)mMiddlePiece.getWidth() * 1.0)
					* .90);
//			System.out.println(mEastWestSize + " " + mNorthSouthSize + " " + mMiddlePiece.getHeight()+ " " + this.getHeight());
//			System.out.println(mScale);
		}
	}

	private void formComponentShown(java.awt.event.ComponentEvent evt) {// GEN-FIRST:event_formComponentShown
		// drawnPieces.clear();
		// drawMaze(mMiddlePiece, getWidth()/2.0, getHeight()/2.0,
		// (Graphics2D)this.getParent().getGraphics()/*JFrame graphics*/);
	}// GEN-LAST:event_formComponentShown

	private void formMouseClicked(java.awt.event.MouseEvent evt) {// GEN-FIRST:event_formMouseClicked
		// drawnPieces.clear();
		// drawMaze(mMiddlePiece, getWidth()/2.0, getHeight()/2.0,
		// (Graphics2D)this.getParent().getGraphics()/*JFrame graphics*/);
	}// GEN-LAST:event_formMouseClicked

	private void formComponentResized(java.awt.event.ComponentEvent evt) {// GEN-FIRST:event_formComponentResized
		// drawnPieces.clear();
		// drawMaze(mMiddlePiece, getWidth()/2.0, getHeight()/2.0,
		// (Graphics2D)this.getParent().getGraphics()/*JFrame graphics*/);
	}// GEN-LAST:event_formComponentResized

	public void setStartingPiece(MazePiece firstPiece) {
		mMiddlePiece = firstPiece;
	}

	public void setEastWestSize(int i) {
		mEastWestSize = i;
		calculateScale();
	}

	public void setNorthSouthSize(int i) {
		mNorthSouthSize = i;
		calculateScale();
	}

	public void setNorthMostLoc(int northMostLoc) {
		mNorthMostLoc = Math.min(mNorthMostLoc, northMostLoc);
	}
	
	public void setSouthMostLoc(int southMostLoc) {
		mSouthMostLoc = Math.max(mSouthMostLoc, southMostLoc);
	}

	public void setEastMostLoc(int eastMostLoc) {
		mEastMostLoc = Math.max(mEastMostLoc, eastMostLoc);
	}

	public void setWestMostLoc(int westMostLoc) {
		 mWestMostLoc = Math.min(mWestMostLoc, westMostLoc);
	}
	
	// Variables declaration - do not modify//GEN-BEGIN:variables
	// End of variables declaration//GEN-END:variables
}
